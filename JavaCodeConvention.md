# 자바 코드 컨벤션(feat.구글 자바 스타일 가이드)

우아한 테크 코스 컨벤션

개발자들은 직업 특성상 협업을 많이 하고 많은 코드들을 작성하고 읽게 되는데 이때 형식과 규칙들이 중요할 것이다.

약속된 규칙이나 형식들이 존재해야 서로가 가독성이 좋고 보완하기 좋은 코드를 만들어 낼 수 있을 것이다.

코드 컨벤션이란 그런 형식이나 규칙, 관습 등에 대한 약속이다.

## 1.개요

---

### 1.1 용어 노트

1. `class` == `"일반적인"클래스`, `enum 클래스`, `인터페이스`혹은 `어노테이션` 타입을 포괄하여 씀.
2. `member(class)` == `중첩클래스`, `필드`, `메소드 혹은 생성자` 즉, 초기화들과 주석들을 제외한 클래스들의 모든 최상위 내용들을 포괄하여 씀.
3. `javadoc` == 주석

## 2.소스파일들의 기본

---

### 2.1 파일 명

소스 파일들의 이름은 최상위 클래스를 포함하는 대소문자를 구별하는 이름들로 되어있고 `.java` 확장자를 가진다.
> ex) Car 클래스(=최상위 클래스) == Car.java

### 2.2 파일 인코딩: UTF-8

### 2.3 특수문자들

#### 2.3.1 공백문자

줄 끝내기 문자를 제외하고 `ASCII horizontal space character(0x20, 수평공백문자)`은 소스파일에 나오는 유일한 공백 문자이다.
이것은 다음을 암시한다:

1. 문자열과 문자들의 다른 모든 공백 문자들은 이스케이프 처리가 된다.
2. `Tab`은 들여쓰기에 사용되지 않는다.

> 보통 IDE를 사용하게 되면 `tab` 을 눌렀을때 위에서 언급된 `ASCII horizontal space character`가 입력되게 된다.

#### 2.3.2 특수 이스케이프 문자들

특수 이스케이프 문자들 (`\b`, `\t`, `\n`, `\f`, `\r`, `\"`, `\'`,`\\`)은 해당 `Octet(\012)` 이나 `유니코드(\u000a)` 이스케이프 대신에 해당 문자가 사용된다.

#### 2.3.3 Non-ASCII 문자들 (수학 기호나 특수 문자와 같은 문자)

실제 `유니코드 문자(ex ∞)`와 `유니코드 이스케이프(ex \u221e)`중 택 1 할 수 있으나 가독성을 고려한다.

주석과 문자열 리터럴 이외의 곳에서 `유니코드 이스케이프`를 사용하는 것은 권장되지 않는다.

예시:

| Example                                                  | Discussion                                      |
|----------------------------------------------------------|:------------------------------------------------|
| `String unitAbbrev = "μs";`                              | 최적: 주석없이도 완벽하다.                                 |
| `String unitAbbrev = "\u03bcs"; // "μs"`                 | 허용, 하지만 이럴 이유는 없음.                              |
| `String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"` | 허용, 하지만 이상하고 실수할 수 있음.                          |
| `String unitAbbrev = "\u03bcs";`                         | 형편없음: 읽는 사람이 알 수가 없음.                           |
| `return '\ufeff' + content; // byte order mark`          | 좋음: 프린트할 수 없는 문자들에 대해 이스케이프를 썼으며 주석이 필요하다면 만든다. |

## 3. 소스 파일 구조

-----

소스 파일의 구성 순서

0. 라이센스나 저작권정보(있다면)
1. 패키지(Package)구문
2. 임포트(import)구문
3. 하나의 최상위 클래스

예시:

```java
/** 라이센스나 저작권 정보 */

package com.example.myapp;

import static java.lang.Math.*;

import java.util.ArrayList;
import java.util.List;

public class Application {

}
```

### 3.1 라이센스나 저작권

만약 라이센스나 저작권정보가 있다면 맨위에 작성

### 3.2 패키지 구문

패키지 서술은 줄바꿈을 하지 않는다 패키지 구문에서 열제한은 없다.(원래 다른 부분에선 열제한 100)

### 3.3 임포트 구문

#### 3.3.1 와일드카드 임포트 하지 않기

와일드 카드 임포트 뿐만아니라 static 형태의 메서드도 와일드 카드로는 사용하지 않는다.

> 예를 들어 List를 import한다면
>```java
>/**와일드 카드 import*/
>import java.util.*; 
>/**static 메서드 와일드 카드 import*/
>import static java.lang.Math.*;
>// 이렇게 와일드 카드를 import 해도 List를 사용할 수 있지만
>
>/**개별 클래스 import*/
>import java.util.List; 
>/**개별 static 메서드 import*/
>import static java.lang.Math.sqrt;
>// List클래스를 개별적으로 import 하는 것이 적절하다. 
>```

#### 3.3.2 줄바꿈 하지않기

임포트 구문도 줄바꿈을 하지 않는다. 열제한 없음

#### 3.3.3 순서와 공간

`static import` 와 `non-static import` 가 모두 있다면 두개의 블럭으로 나누고 두 블럭의 사이는 공백라인으로 구분한다.

같은 블럭 안에서는 공백라인을 사용하지 않는다. 또한 같은 블럭안에서는 클래스 명의 알파벳순으로 정렬한다.
> ex) 클래스명 => ArrayList - List
>```
> import java.util.ArrayList;
> import java.util.List;
>```

#### 3.3.4 클래스에 static 중첩 클래스를 static import 하지 않기

static 중첩 클래스를 가져오려면 static 이 아니라 일반 import를 사용해서 가져와야 한다.

### 3.4 클래스 정의

#### 3.4.1 정확히 최상위 클래스 하나를 정의

#### 3.4.2 클래스 본문 순서 정하기

클래스 안에 멤버들의 초기화 순서는 가독성에 많은 영향을 미친다. 정해진 방법은 없지만 각자의 방법대로 본문을 포함한다.

중요한것은 논리적 순서를 따라야 한다는것, 유지보수자가 질문을 받았을 때 설명할 수 있어야한다.

예를 들어 새로운 메서드를 클래스에 추가할때 단순히 클래스의 끝에 추가하는 것은 날짜순이지 논리적인 순서가 아니다.

#### 3.4.2.1 오버로드 나누지 마라

오버로드 할때 같은 이름의 메소드들 사이에 다른 코드가 없도록한다.

## 4. 포맷팅

----
용어 노트: `block-like construct` (블럭과 같은 구조, 괄호로 나타내어지는 구조를 의미)는 클래스, 함수, 생성자의 몸체를 나타낸다. 4.8.3.1에 나와있는 배열 초기화블럭은 블럭과 같은 구조로
간주될 수 있다.

### 4.1 괄호

### 4.1.1 괄호는 선택사항에서도 쓰인다.

괄호는 `if`, `else`, `for`, `do-while` 구문에 쓰이는데 몸체가 없거나 한 줄의 구문에도 괄호가 쓰인다.

### 4.1.2 비어있지 않은 블럭 : K & R 스타일

괄호는 `비어있지 않은 블럭`과 `block-like construct(중괄호{},블록과 유사한 구조)`,  `Kernighan과 Ritchie 스타일(Egyptian brackets)`을 따른다.

↓`Kernighan과 Ritchie 스타일(Egyptian brackets)`

- 여는 괄호 앞에는 줄 바꿈이 없음
- 여는 괄호 다음에 줄 바꿈
- 닫는 괄호 전에 줄 바꿈
- 닫는 괄호 다음에 줄 바꿈 -> \* 이거는 구문이 끝나거나 메소드, 생성자, 클래스가 끝났을 떄 적용된다. `else`나 `,`뒤에 나오는 부분은 줄바꿈을 하지 않는다.

### 4.1.3 빈 블럭들 : 아마 간결하게

`빈 블럭`이나 `block-like construct` 에서는 K & R 스타일을 따를 수 있다.
대안으로 {} 괄호 안에 문자가 없거나 줄바꿈이라면 열자마자 끝낼 수 있다.
하지만 멀티 블럭 구문에서는 할 수 없다.

예시

```
public class example{
    /** 허용 */
    void doNothing(){}

    /** 마찬가지로 허용 */
    void doNothing(){
    }

    /** 허용되지 않음 */
    try{
    doSomething();
    }catch(Exeception e){}
}
```

### 4.2 블럭들여쓰기: +2 스페이스

**\* 우테코 에서는 +4 스페이스한다.**

`새로운 블럭`이나 `block-like construct`가 열리면 들여쓰기는 스페이스 2번의 공간을 차지한다.
블럭이 끝나면, 들여쓰기는 이전의 들여쓰기 단계로 돌아간다.
들여쓰기 단계는 코드와 주석에 모두 적용된다.

### 4.3 줄 당 하나의 서술

하나의 구문은 줄바꿈이 뒤따른다.

### 4.4 열제한: 100

**\* 우테코는 120**

Java 코드의 열 제한은 100자이다. "문자"는 유니코드 코드 포인트를 의미한다.

예외:

1. 개행이 불가능한 경우 (예를들어, Javadoc의 긴 URL 혹은 긴 JSNI 메서드 레페런스)
2. package 나 import 구문들 (3.2 패키지 구문, 3.3 임포트 구문 참조)
3. 쉘에 복사 붙여넣기 되는 커멘드 라인에 대한 주석

### 4.5 줄 바꿈

용어 노트: 코드가 하나의 줄에서 여러줄로 바뀐다면 그것을 줄 바꿈(개행)이라고 한다.

매 상황별 어떻게 줄 바꿈하는지에 대한 정확한 방법은 없다.

일반적으로 줄바꿈을 하는 이유는 열제한을 초과하지 않기 위해서이다. 하지만 저자의 재량에 따라 열제한을 초과하지 않아도 줄바꿈을 할 수 있다.

> tip: 메서드를 추출하거나 지역변수를 만드는 것은 줄 바꿈을 필요하지 않게 하는 방법이다.

### 4.5.1 언제 바꾸는가

줄 바꿈의 원칙 : 높은 문법 레벨에서 바꾸는 것

1. `non-assignment 연산자`에서 줄바꿈이 일어날 경우 바꿈은 기호 이전에 위치한다. 이것은 `operator-like` 기호에 적용된다.
    - dot`.`
    - 2개의 콜론 `::`
    - 타입 바운딩의 앰퍼센트 기호 `T extends Foo & Bar`
    - catch 블럭의 파이프 `catch (FooExecption | BarException e)`

> non-assignment 연산자: 값을 계산하고 반환하지만 변수에 값을 할당하지 않는 연산자
>
> ex) int result = a + b; 에서 `+` = non-assignment 연산자

2. 줄 바꿈이 assignment 연산자에서 일어나면 기호 다음에 위치하지만 바뀌어도 상관없다.
    - 이것은 향상된 for문의 `assignment-operator-like` 콜론에도 적용된다.
3. 함수나 생성자의 이름에 여는 괄호가 있을 때.
4. 콤마 앞에 오는 토큰에 연결되어 있을 때.
5. 줄은 람다식의 인접한 화살표에서는 바뀌지 않는다. 하지만 람다의 몸체가 한줄로 되어 있다면 바꿔도 된다.

### reference

- [우테코 1기 제이](https://github.com/JunHoPark93/google-java-styleguide#readme)
- [우테코 제공 깃허브](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/java)
- [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)